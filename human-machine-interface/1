#pi
#can you create an html and java script page with audio player that plays flute keys (triangle wave). instead of a horizontal array of buttons to play each note, 
#i want tiny keys laid out in a circular disk. the farthest from the center have the higest pitch like the right end of a piano. the middle has the lowest frequencies. 
#apply a teal color gradient to the keys. when mouse enters an area, it should play that sound. create a toggle for different instruments (like drum beat, guitar)

#sustain pedal and polyphonic cords

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Circular Keys Synth — Polyphonic + Sustain</title>
  <style>
    :root{
      --bg0:#07131a;
      --bg1:#081a22;
      --panel:#0b2530;
      --text:#d7f6ff;
    }
    html,body{height:100%; margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;}
    body{
      background: radial-gradient(1200px 800px at 30% 20%, #0b2a35 0%, var(--bg0) 45%, #050b10 100%);
      color:var(--text);
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .wrap{
      width:min(980px, 96vw);
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:16px;
      align-items:stretch;
    }
    .card{
      background: linear-gradient(180deg, rgba(11,37,48,0.92), rgba(8,26,34,0.92));
      border: 1px solid rgba(120, 220, 255, 0.14);
      box-shadow: 0 20px 60px rgba(0,0,0,0.4);
      border-radius: 18px;
      overflow:hidden;
    }
    .canvasCard{
      position:relative;
      min-height: 520px;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
      touch-action:none;
    }
    canvas{display:block; width:100%; height:100%;}
    .hint{
      position:absolute;
      left:14px; bottom:14px;
      font-size:13px;
      color:rgba(215,246,255,0.78);
      background: rgba(0,0,0,0.18);
      border: 1px solid rgba(120, 220, 255, 0.12);
      padding:10px 12px;
      border-radius: 12px;
      backdrop-filter: blur(8px);
      max-width: 72%;
      line-height:1.35;
    }
    .controls{
      padding:16px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .controls h2{margin:2px 0 6px; font-size:16px; color:rgba(215,246,255,0.92);}
    label{font-size:13px; color:rgba(215,246,255,0.78);}
    select{
      width:100%;
      background: rgba(0,0,0,0.18);
      border: 1px solid rgba(120, 220, 255, 0.16);
      color: var(--text);
      padding:10px 12px;
      border-radius: 12px;
      outline:none;
    }
    input[type="range"]{width:100%;}
    .pill{
      background: rgba(0,0,0,0.16);
      border: 1px solid rgba(120, 220, 255, 0.12);
      padding:12px;
      border-radius: 14px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .row{display:flex; gap:10px; align-items:center; justify-content:space-between;}
    .small{font-size:12px; color:rgba(215,246,255,0.65); line-height:1.35;}
    .btn{
      width:100%;
      padding:10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(120, 220, 255, 0.2);
      background: linear-gradient(180deg, rgba(0, 191, 191, 0.18), rgba(0, 120, 140, 0.12));
      color: var(--text);
      cursor:pointer;
    }
    .btn:active{transform: translateY(1px);}
    .toggle{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:12px;
      border-radius: 14px;
      background: rgba(0,0,0,0.16);
      border: 1px solid rgba(120, 220, 255, 0.12);
    }
    .switch{
      width:44px; height:26px; border-radius:999px;
      background: rgba(255,255,255,0.12);
      border: 1px solid rgba(120, 220, 255, 0.18);
      position:relative;
      cursor:pointer;
      flex:none;
    }
    .knob{
      position:absolute; top:3px; left:3px;
      width:20px; height:20px; border-radius:999px;
      background: rgba(215,246,255,0.82);
      box-shadow: 0 8px 18px rgba(0,0,0,0.35);
      transition: transform 120ms ease;
    }
    .switch.on{background: rgba(0, 191, 191, 0.18);}
    .switch.on .knob{transform: translateX(18px);}

    .status{
      font-size:12px;
      color:rgba(215,246,255,0.72);
      padding:10px 12px;
      border-radius: 12px;
      background: rgba(0,0,0,0.14);
      border: 1px solid rgba(120, 220, 255, 0.1);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card canvasCard" id="canvasCard">
      <canvas id="disk"></canvas>
      <div class="hint">
        <b>Polyphonic:</b> hold mouse button and drag to add notes (chords).<br/>
        <b>Sustain:</b> toggle sustain on, then released notes will keep ringing until sustain off.<br/>
        Tip: Click once to unlock audio if needed.
      </div>
    </div>

    <div class="card controls">
      <h2>Instrument + Performance</h2>

      <div class="pill">
        <label for="instrument">Instrument</label>
        <select id="instrument">
          <option value="flute" selected>Flute (triangle wave)</option>
          <option value="guitar">Guitar (plucked)</option>
          <option value="drum">Drum (percussive)</option>
        </select>
        <div class="small">Chords are best with flute & guitar; drums trigger per hit.</div>
      </div>

      <div class="toggle">
        <div>
          <div style="font-size:13px; color:rgba(215,246,255,0.88); font-weight:600;">Sustain pedal</div>
          <div class="small">Released notes keep sounding until you turn sustain off.</div>
        </div>
        <div class="switch" id="sustainSwitch" role="switch" aria-checked="false" tabindex="0">
          <div class="knob"></div>
        </div>
      </div>

      <div class="pill">
        <div class="row"><label for="volume">Volume</label><span id="volLabel" class="small">70%</span></div>
        <input id="volume" type="range" min="0" max="1" step="0.01" value="0.70"/>
      </div>

      <div class="pill">
        <div class="row"><label for="attack">Attack</label><span id="atkLabel" class="small">8 ms</span></div>
        <input id="attack" type="range" min="0" max="0.08" step="0.001" value="0.008"/>

        <div class="row" style="margin-top:10px;"><label for="release">Release</label><span id="relLabel" class="small">220 ms</span></div>
        <input id="release" type="range" min="0.03" max="1.2" step="0.01" value="0.22"/>
      </div>

      <button class="btn" id="panic">Panic (stop all)</button>
      <div class="status" id="status">Audio: <b>not started</b></div>

      <div class="small">
        Key mapping: center ≈ A2 (110 Hz) → outer ≈ A6 (1760 Hz).<br/>
        Dragging while mouse-down adds wedges to a chord (polyphony).
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------------- Audio ----------------
  let audioCtx = null;
  let master = null;

  // Active voices split into:
  // 1) held (currently pressed / pointer is down and key included in chord)
  // 2) sustained (released while sustain is on; keep sounding until sustain off)
  // 3) free (one-shot voices like drums; can be ignored)
  const heldVoices = new Map();      // keyId -> voice
  const sustainedVoices = new Map(); // keyId -> voice (same object; just different state)

  function ensureAudio() {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      master = audioCtx.createGain();
      master.gain.value = parseFloat(volumeEl.value);
      master.connect(audioCtx.destination);
      setStatus("Audio: <b>running</b>");
    }
    if (audioCtx.state === "suspended") audioCtx.resume();
  }

  function setStatus(html) { statusEl.innerHTML = html; }

  // --------------- UI ----------------
  const instrumentEl = document.getElementById("instrument");
  const volumeEl = document.getElementById("volume");
  const attackEl = document.getElementById("attack");
  const releaseEl = document.getElementById("release");
  const volLabel = document.getElementById("volLabel");
  const atkLabel = document.getElementById("atkLabel");
  const relLabel = document.getElementById("relLabel");
  const panicBtn = document.getElementById("panic");
  const statusEl = document.getElementById("status");
  const sustainSwitch = document.getElementById("sustainSwitch");

  let sustainOn = false;
  function setSustain(on) {
    sustainOn = !!on;
    sustainSwitch.classList.toggle("on", sustainOn);
    sustainSwitch.setAttribute("aria-checked", sustainOn ? "true" : "false");
    if (!sustainOn) {
      // When sustain is released, fade out anything that was sustained (but not currently held).
      const now = audioCtx ? audioCtx.currentTime : 0;
      for (const [keyId, voice] of sustainedVoices) {
        if (!heldVoices.has(keyId)) {
          try { voice.stop(now); } catch {}
          sustainedVoices.delete(keyId);
        }
      }
      setStatus("Audio: <b>running</b> • sustain: <b>off</b>");
    } else {
      setStatus("Audio: <b>running</b> • sustain: <b>on</b>");
    }
  }

  sustainSwitch.addEventListener("click", () => { ensureAudio(); setSustain(!sustainOn); });
  sustainSwitch.addEventListener("keydown", (e) => {
    if (e.key === "Enter" || e.key === " ") { e.preventDefault(); ensureAudio(); setSustain(!sustainOn); }
  });

  volumeEl.addEventListener("input", () => {
    volLabel.textContent = Math.round(parseFloat(volumeEl.value) * 100) + "%";
    if (master) master.gain.setTargetAtTime(parseFloat(volumeEl.value), audioCtx.currentTime, 0.01);
  });
  attackEl.addEventListener("input", () => atkLabel.textContent = Math.round(parseFloat(attackEl.value) * 1000) + " ms");
  releaseEl.addEventListener("input", () => relLabel.textContent = Math.round(parseFloat(releaseEl.value) * 1000) + " ms");

  // ---------------- Circular keys ----------------
  const canvas = document.getElementById("disk");
  const card = document.getElementById("canvasCard");
  const ctx2d = canvas.getContext("2d");

  const RINGS = 5;
  const WEDGES = 16;

  const BASE_FREQ = 110;   // A2
  const TOP_FREQ  = 1760;  // A6
  const STEPS = RINGS * WEDGES - 1;

  function stepToFreq(step) {
    const t = STEPS === 0 ? 0 : (step / STEPS);
    return BASE_FREQ * Math.pow(TOP_FREQ / BASE_FREQ, t);
  }

  function getCenter() {
    const rect = card.getBoundingClientRect();
    return { cx: rect.width / 2, cy: rect.height / 2 };
  }

  function tealGradientColor(ringIdx, wedgeIdx, state) {
    // state: "idle" | "hover" | "held" | "sustained"
    const t = (ringIdx + (wedgeIdx / WEDGES) * 0.4) / (RINGS - 1);
    const hue = 176 + 12 * t;
    const sat = 72 + 10 * (1 - t);

    let lit = 42 + 18 * t;
    if (state === "hover") lit += 14;
    if (state === "held") lit += 22;
    if (state === "sustained") lit += 10;

    return `hsl(${hue} ${sat}% ${lit}%)`;
  }

  function resize() {
    const rect = card.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    canvas.style.width = rect.width + "px";
    canvas.style.height = rect.height + "px";
    ctx2d.setTransform(dpr, 0, 0, dpr, 0, 0);
    drawDisk();
  }
  window.addEventListener("resize", resize);

  function hitTest(x, y) {
    const { cx, cy } = getCenter();
    const dx = x - cx, dy = y - cy;
    const r = Math.hypot(dx, dy);

    const minDim = Math.min(card.getBoundingClientRect().width, card.getBoundingClientRect().height);
    const outerR = minDim * 0.42;
    const innerR = minDim * 0.08;

    if (r < innerR || r > outerR) return null;

    const ringWidth = (outerR - innerR) / RINGS;
    const ringIdx = Math.min(RINGS - 1, Math.max(0, Math.floor((r - innerR) / ringWidth)));

    let ang = Math.atan2(dy, dx);
    if (ang < 0) ang += Math.PI * 2;
    const rot = -Math.PI / 2; // put 0 at top
    ang = (ang + rot + Math.PI * 2) % (Math.PI * 2);
    const wedgeIdx = Math.min(WEDGES - 1, Math.floor((ang / (Math.PI * 2)) * WEDGES));

    const step = ringIdx * WEDGES + wedgeIdx;
    return { ringIdx, wedgeIdx, step, freq: stepToFreq(step) };
  }

  let hoveredKey = null;

  function drawDisk() {
    const rect = card.getBoundingClientRect();
    const w = rect.width, h = rect.height;
    ctx2d.clearRect(0, 0, w, h);

    const minDim = Math.min(w, h);
    const outerR = minDim * 0.42;
    const innerR = minDim * 0.08;
    const ringWidth = (outerR - innerR) / RINGS;
    const { cx, cy } = getCenter();

    // vignette
    const bg = ctx2d.createRadialGradient(w/2, h/2, 10, w/2, h/2, Math.min(w,h)*0.52);
    bg.addColorStop(0, "rgba(12, 56, 70, 0.55)");
    bg.addColorStop(0.55, "rgba(5, 15, 20, 0.25)");
    bg.addColorStop(1, "rgba(0, 0, 0, 0)");
    ctx2d.fillStyle = bg;
    ctx2d.fillRect(0, 0, w, h);

    for (let ring=0; ring<RINGS; ring++) {
      const r0 = innerR + ring*ringWidth;
      const r1 = r0 + ringWidth - 2;

      for (let wedge=0; wedge<WEDGES; wedge++) {
        const a0 = (wedge / WEDGES) * Math.PI*2 - Math.PI/2;
        const a1 = ((wedge+1) / WEDGES) * Math.PI*2 - Math.PI/2;

        const keyId = `${ring}-${wedge}`;
        const isHover = hoveredKey && hoveredKey.ringIdx === ring && hoveredKey.wedgeIdx === wedge;
        const isHeld = heldVoices.has(keyId);
        const isSus  = sustainedVoices.has(keyId) && !isHeld;

        let state = "idle";
        if (isSus) state = "sustained";
        if (isHeld) state = "held";
        if (isHover) state = isHeld ? "held" : "hover";

        ctx2d.beginPath();
        ctx2d.arc(cx, cy, r1, a0, a1, false);
        ctx2d.arc(cx, cy, r0, a1, a0, true);
        ctx2d.closePath();

        ctx2d.fillStyle = tealGradientColor(ring, wedge, state);
        ctx2d.fill();

        ctx2d.lineWidth = (isHeld || isSus) ? 2 : (isHover ? 2 : 1);
        ctx2d.strokeStyle = (isHeld || isSus)
          ? "rgba(240, 255, 255, 0.55)"
          : (isHover ? "rgba(220, 255, 255, 0.45)" : "rgba(210, 255, 255, 0.18)");
        ctx2d.stroke();
      }
    }

    // center
    ctx2d.beginPath();
    ctx2d.arc(cx, cy, innerR - 2, 0, Math.PI*2);
    ctx2d.fillStyle = "rgba(0,0,0,0.28)";
    ctx2d.fill();
    ctx2d.lineWidth = 1;
    ctx2d.strokeStyle = "rgba(180, 245, 255, 0.18)";
    ctx2d.stroke();

    ctx2d.textAlign = "center";
    ctx2d.textBaseline = "middle";
    ctx2d.fillStyle = "rgba(215,246,255,0.85)";
    ctx2d.font = "600 13px ui-sans-serif, system-ui";
    ctx2d.fillText("SYNTH", cx, cy - 8);

    ctx2d.fillStyle = "rgba(215,246,255,0.62)";
    ctx2d.font = "12px ui-sans-serif, system-ui";
    ctx2d.fillText(sustainOn ? "SUSTAIN ON" : "SUSTAIN OFF", cx, cy + 12);
  }

  // ---------------- Voice building ----------------
  function envelope(gainNode, t0, attack, release, peak=0.9, sustain=0.55) {
    const g = gainNode.gain;
    g.cancelScheduledValues(t0);
    g.setValueAtTime(0.0001, t0);
    g.linearRampToValueAtTime(peak, t0 + attack);
    g.exponentialRampToValueAtTime(Math.max(0.0001, sustain), t0 + attack + 0.06);

    return (tStop) => {
      const tt = tStop ?? (audioCtx.currentTime);
      g.cancelScheduledValues(tt);
      g.setValueAtTime(Math.max(g.value, 0.0001), tt);
      g.exponentialRampToValueAtTime(0.0001, tt + release);
    };
  }

  function playFlute(freq) {
    const t0 = audioCtx.currentTime;
    const attack = parseFloat(attackEl.value);
    const release = parseFloat(releaseEl.value);

    const osc = audioCtx.createOscillator();
    osc.type = "triangle";
    osc.frequency.setValueAtTime(freq, t0);

    // breath noise
    const noise = audioCtx.createBufferSource();
    const buf = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate * 0.2), audioCtx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * 0.22;
    noise.buffer = buf;
    noise.loop = true;

    const noiseFilter = audioCtx.createBiquadFilter();
    noiseFilter.type = "bandpass";
    noiseFilter.frequency.setValueAtTime(Math.min(2600, Math.max(500, freq * 6)), t0);
    noiseFilter.Q.setValueAtTime(6, t0);

    const vca = audioCtx.createGain();
    const stopEnv = envelope(vca, t0, attack, release, 0.75, 0.45);

    // vibrato
    const lfo = audioCtx.createOscillator();
    lfo.type = "sine";
    lfo.frequency.setValueAtTime(5.5, t0);
    const lfoGain = audioCtx.createGain();
    lfoGain.gain.setValueAtTime(7.5, t0);
    lfo.connect(lfoGain).connect(osc.frequency);

    osc.connect(vca);
    noise.connect(noiseFilter).connect(vca);
    vca.connect(master);

    lfo.start(t0);
    osc.start(t0);
    noise.start(t0);

    // Do not set a short hard-stop; sustain needs indefinite.
    return {
      stop: (tStop) => {
        const tt = tStop ?? audioCtx.currentTime;
        stopEnv(tt);
        const end = tt + release + 0.08;
        try { osc.stop(end); } catch {}
        try { noise.stop(end); } catch {}
        try { lfo.stop(end); } catch {}
      }
    };
  }

  function playGuitar(freq) {
    const t0 = audioCtx.currentTime;
    const attack = Math.min(0.01, parseFloat(attackEl.value));
    const release = Math.max(0.06, parseFloat(releaseEl.value));

    const noise = audioCtx.createBufferSource();
    const dur = 0.07;
    const buf = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate * dur), audioCtx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * (1 - i/data.length);
    noise.buffer = buf;

    const lp = audioCtx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.setValueAtTime(Math.min(8000, Math.max(800, freq * 6)), t0);
    lp.Q.setValueAtTime(0.6, t0);

    const reson = audioCtx.createBiquadFilter();
    reson.type = "bandpass";
    reson.frequency.setValueAtTime(freq, t0);
    reson.Q.setValueAtTime(10, t0);

    const vca = audioCtx.createGain();
    const stopEnv = envelope(vca, t0, attack, release, 1.0, 0.0001);

    noise.connect(lp).connect(reson).connect(vca).connect(master);
    noise.start(t0);

    return {
      stop: (tStop) => {
        const tt = tStop ?? audioCtx.currentTime;
        stopEnv(tt);
      }
    };
  }

  function playDrum(freq) {
    // Drums are "one-shot": sustain doesn't really apply, but we still allow poly triggers.
    const t0 = audioCtx.currentTime;

    const t = (Math.log(freq) - Math.log(BASE_FREQ)) / (Math.log(TOP_FREQ) - Math.log(BASE_FREQ));

    const vca = audioCtx.createGain();
    vca.gain.setValueAtTime(0.0001, t0);
    vca.connect(master);

    if (t < 0.33) {
      const osc = audioCtx.createOscillator();
      osc.type = "sine";
      osc.frequency.setValueAtTime(150, t0);
      osc.frequency.exponentialRampToValueAtTime(55, t0 + 0.08);
      vca.gain.exponentialRampToValueAtTime(0.95, t0 + 0.005);
      vca.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.25);
      osc.connect(vca);
      osc.start(t0);
      osc.stop(t0 + 0.26);
      return { stop: () => {} };
    } else if (t < 0.66) {
      const noise = audioCtx.createBufferSource();
      const dur = 0.14;
      const buf = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate * dur), audioCtx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1);
      noise.buffer = buf;

      const hp = audioCtx.createBiquadFilter();
      hp.type = "highpass";
      hp.frequency.setValueAtTime(900, t0);

      vca.gain.exponentialRampToValueAtTime(0.9, t0 + 0.004);
      vca.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.18);

      noise.connect(hp).connect(vca);
      noise.start(t0);
      return { stop: () => {} };
    } else {
      const noise = audioCtx.createBufferSource();
      const dur = 0.07;
      const buf = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate * dur), audioCtx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1);
      noise.buffer = buf;

      const bp = audioCtx.createBiquadFilter();
      bp.type = "bandpass";
      bp.frequency.setValueAtTime(8500, t0);
      bp.Q.setValueAtTime(2.0, t0);

      vca.gain.exponentialRampToValueAtTime(0.7, t0 + 0.002);
      vca.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.08);

      noise.connect(bp).connect(vca);
      noise.start(t0);
      return { stop: () => {} };
    }
  }

  function playVoice(freq) {
    ensureAudio();
    const inst = instrumentEl.value;
    if (inst === "flute") return playFlute(freq);
    if (inst === "guitar") return playGuitar(freq);
    return playDrum(freq);
  }

  // ---------------- Polyphonic interaction ----------------
  // Chord mode:
  // - pointerdown begins a chord
  // - while pointer is down, moving across new keys adds them to chord (polyphony)
  // - pointerup releases all held keys: if sustain on => move them to sustained; else stop them
  let isDown = false;
  let chordKeySet = new Set(); // keys currently held in this gesture

  function getPointerPos(evt) {
    const rect = card.getBoundingClientRect();
    return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
  }

  function addKeyToChord(hit) {
    if (!hit) return;
    const keyId = `${hit.ringIdx}-${hit.wedgeIdx}`;
    if (chordKeySet.has(keyId)) return;

    chordKeySet.add(keyId);

    // If already sustained, we don't need a new voice; just mark it as held too.
    if (sustainedVoices.has(keyId)) {
      heldVoices.set(keyId, sustainedVoices.get(keyId));
      drawDisk();
      setStatus(`Audio: <b>running</b> • chord notes: <b>${chordKeySet.size}</b>`);
      return;
    }

    // Otherwise, start a new voice for this key
    const voice = playVoice(hit.freq);
    heldVoices.set(keyId, voice);
    drawDisk();
    setStatus(`Audio: <b>running</b> • chord notes: <b>${chordKeySet.size}</b>`);
  }

  function releaseChord() {
    if (!audioCtx) return;

    const now = audioCtx.currentTime;

    for (const keyId of chordKeySet) {
      const voice = heldVoices.get(keyId);
      if (!voice) continue;

      // Drums are one-shots; ignore sustain behavior
      if (instrumentEl.value === "drum") {
        heldVoices.delete(keyId);
        sustainedVoices.delete(keyId);
        continue;
      }

      if (sustainOn) {
        sustainedVoices.set(keyId, voice);
        heldVoices.delete(keyId);
      } else {
        try { voice.stop(now); } catch {}
        heldVoices.delete(keyId);
        sustainedVoices.delete(keyId);
      }
    }

    chordKeySet.clear();
    drawDisk();
    setStatus(`Audio: <b>running</b> • chord released • sustain: <b>${sustainOn ? "on" : "off"}</b>`);
  }

  // Hover feedback
  function updateHover(evt) {
    const { x, y } = getPointerPos(evt);
    const hit = hitTest(x, y);
    const old = hoveredKey ? `${hoveredKey.ringIdx}-${hoveredKey.wedgeIdx}` : null;
    const neu = hit ? `${hit.ringIdx}-${hit.wedgeIdx}` : null;
    hoveredKey = hit;
    if (old !== neu) drawDisk();

    // If mouse is down, add keys to the chord (polyphonic)
    if (isDown) addKeyToChord(hit);
  }

  // Pointer events
  card.addEventListener("pointerdown", (evt) => {
    ensureAudio();
    isDown = true;
    chordKeySet.clear();
    card.setPointerCapture(evt.pointerId);
    updateHover(evt);
    // start with whatever is under the pointer immediately
    addKeyToChord(hoveredKey);
  });

  card.addEventListener("pointermove", (evt) => {
    updateHover(evt);
  });

  card.addEventListener("pointerup", (evt) => {
    isDown = false;
    releaseChord();
    try { card.releasePointerCapture(evt.pointerId); } catch {}
  });

  card.addEventListener("pointercancel", () => {
    isDown = false;
    releaseChord();
  });

  card.addEventListener("pointerleave", () => {
    hoveredKey = null;
    drawDisk();
  });

  // Panic: stop everything immediately
  function stopAll() {
    if (!audioCtx) return;
    const now = audioCtx.currentTime;
    for (const [, v] of heldVoices) { try { v.stop(now); } catch {} }
    for (const [, v] of sustainedVoices) { try { v.stop(now); } catch {} }
    heldVoices.clear();
    sustainedVoices.clear();
    chordKeySet.clear();
    drawDisk();
  }
  panicBtn.addEventListener("click", () => {
    ensureAudio();
    stopAll();
    setStatus("Audio: <b>running</b> • all voices stopped");
  });

  // Switching instruments: stop held notes, but allow sustained notes to keep (optional).
  // Here: we stop everything to avoid mixing different timbres under sustain.
  instrumentEl.addEventListener("change", () => {
    ensureAudio();
    stopAll();
    drawDisk();
    setStatus(`Audio: <b>running</b> • instrument: <b>${instrumentEl.value}</b>`);
  });

  // Init
  function initLabels() {
    volLabel.textContent = Math.round(parseFloat(volumeEl.value) * 100) + "%";
    atkLabel.textContent = Math.round(parseFloat(attackEl.value) * 1000) + " ms";
    relLabel.textContent = Math.round(parseFloat(releaseEl.value) * 1000) + " ms";
  }

  initLabels();
  resize();
})();
</script>
</body>
</html>
